// Type definitions for @mtproto/core 6.2
// Project: https://github.com/alik0211/mtproto-core
// Definitions by: Viktor Shchelochkov <https://github.com/VityaSchel>, Ali Gasymov <https://github.com/alik0211>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

export default class MTProto {
  constructor(options: {
    api_id: number,
    api_hash: string,
    test?: boolean,
    customLocalStorage?: MyAsyncLocalStorage,
    storageOptions?: {
      path: string;
    };
  });

  call(method: string, params?: object, options?: {
    dcId?: number,
    syncAuth?: boolean,
  }): Promise<object>;
  call(method: 'invokeAfterMsg', params: { msg_id: number, query: !X }): Promise<X>;
  call(method: 'invokeAfterMsgs', params: { msg_ids: number[], query: !X }): Promise<X>;
  call(method: 'auth.sendCode', params: { phone_number: string, api_id: number, api_hash: string, settings: CodeSettings }): Promise<auth_SentCode>;
  call(method: 'auth.signUp', params: { phone_number: string, phone_code_hash: string, first_name: string, last_name: string }): Promise<auth_Authorization>;
  call(method: 'auth.signIn', params: { phone_number: string, phone_code_hash: string, phone_code: string }): Promise<auth_Authorization>;
  call(method: 'auth.logOut'): Promise<auth_LoggedOut>;
  call(method: 'auth.resetAuthorizations'): Promise<Bool>;
  call(method: 'auth.exportAuthorization', params: { dc_id: number }): Promise<auth_ExportedAuthorization>;
  call(method: 'auth.importAuthorization', params: { id: number, bytes: UInt8Array }): Promise<auth_Authorization>;
  call(method: 'auth.bindTempAuthKey', params: { perm_auth_key_id: number, nonce: number, expires_at: number, encrypted_message: UInt8Array }): Promise<Bool>;
  call(method: 'account.registerDevice', params: { flags: #, no_muted?: boolean, token_type: number, token: string, app_sandbox: boolean, secret: UInt8Array, other_uids: number[] }): Promise<Bool>;
  call(method: 'account.unregisterDevice', params: { token_type: number, token: string, other_uids: number[] }): Promise<Bool>;
  call(method: 'account.updateNotifySettings', params: { peer: InputNotifyPeer, settings: InputPeerNotifySettings }): Promise<Bool>;
  call(method: 'account.getNotifySettings', params: { peer: InputNotifyPeer }): Promise<PeerNotifySettings>;
  call(method: 'account.resetNotifySettings'): Promise<Bool>;
  call(method: 'account.updateProfile', params: { flags: #, first_name?: string, last_name?: string, about?: string }): Promise<User>;
  call(method: 'account.updateStatus', params: { offline: boolean }): Promise<Bool>;
  call(method: 'account.getWallPapers', params: { hash: number }): Promise<account_WallPapers>;
  call(method: 'account.reportPeer', params: { peer: InputPeer, reason: ReportReason, message: string }): Promise<Bool>;
  call(method: 'users.getUsers', params: { id: InputUser[] }): Promise<Vector<User>>;
  call(method: 'users.getFullUser', params: { id: InputUser }): Promise<users_UserFull>;
  call(method: 'contacts.getContactIDs', params: { hash: number }): Promise<Vector<int>>;
  call(method: 'contacts.getStatuses'): Promise<Vector<ContactStatus>>;
  call(method: 'contacts.getContacts', params: { hash: number }): Promise<contacts_Contacts>;
  call(method: 'contacts.importContacts', params: { contacts: InputContact[] }): Promise<contacts_ImportedContacts>;
  call(method: 'contacts.deleteContacts', params: { id: InputUser[] }): Promise<Updates>;
  call(method: 'contacts.deleteByPhones', params: { phones: string[] }): Promise<Bool>;
  call(method: 'contacts.block', params: { id: InputPeer }): Promise<Bool>;
  call(method: 'contacts.unblock', params: { id: InputPeer }): Promise<Bool>;
  call(method: 'contacts.getBlocked', params: { offset: number, limit: number }): Promise<contacts_Blocked>;
  call(method: 'messages.getMessages', params: { id: InputMessage[] }): Promise<messages_Messages>;
  call(method: 'messages.getDialogs', params: { flags: #, exclude_pinned?: boolean, folder_id?: number, offset_date: number, offset_id: number, offset_peer: InputPeer, limit: number, hash: number }): Promise<messages_Dialogs>;
  call(method: 'messages.getHistory', params: { peer: InputPeer, offset_id: number, offset_date: number, add_offset: number, limit: number, max_id: number, min_id: number, hash: number }): Promise<messages_Messages>;
  call(method: 'messages.search', params: { flags: #, peer: InputPeer, q: string, from_id?: InputPeer, top_msg_id?: number, filter: MessagesFilter, min_date: number, max_date: number, offset_id: number, add_offset: number, limit: number, max_id: number, min_id: number, hash: number }): Promise<messages_Messages>;
  call(method: 'messages.readHistory', params: { peer: InputPeer, max_id: number }): Promise<messages_AffectedMessages>;
  call(method: 'messages.deleteHistory', params: { flags: #, just_clear?: boolean, revoke?: boolean, peer: InputPeer, max_id: number, min_date?: number, max_date?: number }): Promise<messages_AffectedHistory>;
  call(method: 'messages.deleteMessages', params: { flags: #, revoke?: boolean, id: number[] }): Promise<messages_AffectedMessages>;
  call(method: 'messages.receivedMessages', params: { max_id: number }): Promise<Vector<ReceivedNotifyMessage>>;
  call(method: 'messages.setTyping', params: { flags: #, peer: InputPeer, top_msg_id?: number, action: SendMessageAction }): Promise<Bool>;
  call(method: 'messages.sendMessage', params: { flags: #, no_webpage?: boolean, silent?: boolean, background?: boolean, clear_draft?: boolean, noforwards?: boolean, peer: InputPeer, reply_to_msg_id?: number, message: string, random_id: number, reply_markup?: ReplyMarkup, entities?: MessageEntity[], schedule_date?: number, send_as?: InputPeer }): Promise<Updates>;
  call(method: 'messages.sendMedia', params: { flags: #, silent?: boolean, background?: boolean, clear_draft?: boolean, noforwards?: boolean, peer: InputPeer, reply_to_msg_id?: number, media: InputMedia, message: string, random_id: number, reply_markup?: ReplyMarkup, entities?: MessageEntity[], schedule_date?: number, send_as?: InputPeer }): Promise<Updates>;
  call(method: 'messages.forwardMessages', params: { flags: #, silent?: boolean, background?: boolean, with_my_score?: boolean, drop_author?: boolean, drop_media_captions?: boolean, noforwards?: boolean, from_peer: InputPeer, id: number[], random_id: number[], to_peer: InputPeer, schedule_date?: number, send_as?: InputPeer }): Promise<Updates>;
  call(method: 'messages.reportSpam', params: { peer: InputPeer }): Promise<Bool>;
  call(method: 'messages.getPeerSettings', params: { peer: InputPeer }): Promise<messages_PeerSettings>;
  call(method: 'messages.report', params: { peer: InputPeer, id: number[], reason: ReportReason, message: string }): Promise<Bool>;
  call(method: 'messages.getChats', params: { id: number[] }): Promise<messages_Chats>;
  call(method: 'messages.getFullChat', params: { chat_id: number }): Promise<messages_ChatFull>;
  call(method: 'messages.editChatTitle', params: { chat_id: number, title: string }): Promise<Updates>;
  call(method: 'messages.editChatPhoto', params: { chat_id: number, photo: InputChatPhoto }): Promise<Updates>;
  call(method: 'messages.addChatUser', params: { chat_id: number, user_id: InputUser, fwd_limit: number }): Promise<Updates>;
  call(method: 'messages.deleteChatUser', params: { flags: #, revoke_history?: boolean, chat_id: number, user_id: InputUser }): Promise<Updates>;
  call(method: 'messages.createChat', params: { users: InputUser[], title: string }): Promise<Updates>;
  call(method: 'updates.getState'): Promise<updates_State>;
  call(method: 'updates.getDifference', params: { flags: #, pts: number, pts_total_limit?: number, date: number, qts: number }): Promise<updates_Difference>;
  call(method: 'photos.updateProfilePhoto', params: { id: InputPhoto }): Promise<photos_Photo>;
  call(method: 'photos.uploadProfilePhoto', params: { flags: #, file?: InputFile, video?: InputFile, video_start_ts?: number }): Promise<photos_Photo>;
  call(method: 'photos.deletePhotos', params: { id: InputPhoto[] }): Promise<Vector<long>>;
  call(method: 'upload.saveFilePart', params: { file_id: number, file_part: number, bytes: UInt8Array }): Promise<Bool>;
  call(method: 'upload.getFile', params: { flags: #, precise?: boolean, cdn_supported?: boolean, location: InputFileLocation, offset: number, limit: number }): Promise<upload_File>;
  call(method: 'help.getConfig'): Promise<Config>;
  call(method: 'help.getNearestDc'): Promise<NearestDc>;
  call(method: 'help.getAppUpdate', params: { source: string }): Promise<help_AppUpdate>;
  call(method: 'help.getInviteText'): Promise<help_InviteText>;
  call(method: 'photos.getUserPhotos', params: { user_id: InputUser, offset: number, max_id: number, limit: number }): Promise<photos_Photos>;
  call(method: 'messages.getDhConfig', params: { version: number, random_length: number }): Promise<messages_DhConfig>;
  call(method: 'messages.requestEncryption', params: { user_id: InputUser, random_id: number, g_a: UInt8Array }): Promise<EncryptedChat>;
  call(method: 'messages.acceptEncryption', params: { peer: InputEncryptedChat, g_b: UInt8Array, key_fingerprint: number }): Promise<EncryptedChat>;
  call(method: 'messages.discardEncryption', params: { flags: #, delete_history?: boolean, chat_id: number }): Promise<Bool>;
  call(method: 'messages.setEncryptedTyping', params: { peer: InputEncryptedChat, typing: boolean }): Promise<Bool>;
  call(method: 'messages.readEncryptedHistory', params: { peer: InputEncryptedChat, max_date: number }): Promise<Bool>;
  call(method: 'messages.sendEncrypted', params: { flags: #, silent?: boolean, peer: InputEncryptedChat, random_id: number, data: UInt8Array }): Promise<messages_SentEncryptedMessage>;
  call(method: 'messages.sendEncryptedFile', params: { flags: #, silent?: boolean, peer: InputEncryptedChat, random_id: number, data: UInt8Array, file: InputEncryptedFile }): Promise<messages_SentEncryptedMessage>;
  call(method: 'messages.sendEncryptedService', params: { peer: InputEncryptedChat, random_id: number, data: UInt8Array }): Promise<messages_SentEncryptedMessage>;
  call(method: 'messages.receivedQueue', params: { max_qts: number }): Promise<Vector<long>>;
  call(method: 'messages.reportEncryptedSpam', params: { peer: InputEncryptedChat }): Promise<Bool>;
  call(method: 'upload.saveBigFilePart', params: { file_id: number, file_part: number, file_total_parts: number, bytes: UInt8Array }): Promise<Bool>;
  call(method: 'initConnection', params: { flags: #, api_id: number, device_model: string, system_version: string, app_version: string, system_lang_code: string, lang_pack: string, lang_code: string, proxy?: InputClientProxy, params?: JSONValue, query: !X }): Promise<X>;
  call(method: 'help.getSupport'): Promise<help_Support>;
  call(method: 'messages.readMessageContents', params: { id: number[] }): Promise<messages_AffectedMessages>;
  call(method: 'account.checkUsername', params: { username: string }): Promise<Bool>;
  call(method: 'account.updateUsername', params: { username: string }): Promise<User>;
  call(method: 'contacts.search', params: { q: string, limit: number }): Promise<contacts_Found>;
  call(method: 'account.getPrivacy', params: { key: InputPrivacyKey }): Promise<account_PrivacyRules>;
  call(method: 'account.setPrivacy', params: { key: InputPrivacyKey, rules: InputPrivacyRule[] }): Promise<account_PrivacyRules>;
  call(method: 'account.deleteAccount', params: { reason: string }): Promise<Bool>;
  call(method: 'account.getAccountTTL'): Promise<AccountDaysTTL>;
  call(method: 'account.setAccountTTL', params: { ttl: AccountDaysTTL }): Promise<Bool>;
  call(method: 'invokeWithLayer', params: { layer: number, query: !X }): Promise<X>;
  call(method: 'contacts.resolveUsername', params: { username: string }): Promise<contacts_ResolvedPeer>;
  call(method: 'account.sendChangePhoneCode', params: { phone_number: string, settings: CodeSettings }): Promise<auth_SentCode>;
  call(method: 'account.changePhone', params: { phone_number: string, phone_code_hash: string, phone_code: string }): Promise<User>;
  call(method: 'messages.getStickers', params: { emoticon: string, hash: number }): Promise<messages_Stickers>;
  call(method: 'messages.getAllStickers', params: { hash: number }): Promise<messages_AllStickers>;
  call(method: 'account.updateDeviceLocked', params: { period: number }): Promise<Bool>;
  call(method: 'auth.importBotAuthorization', params: { flags: number, api_id: number, api_hash: string, bot_auth_token: string }): Promise<auth_Authorization>;
  call(method: 'messages.getWebPagePreview', params: { flags: #, message: string, entities?: MessageEntity[] }): Promise<MessageMedia>;
  call(method: 'account.getAuthorizations'): Promise<account_Authorizations>;
  call(method: 'account.resetAuthorization', params: { hash: number }): Promise<Bool>;
  call(method: 'account.getPassword'): Promise<account_Password>;
  call(method: 'account.getPasswordSettings', params: { password: InputCheckPasswordSRP }): Promise<account_PasswordSettings>;
  call(method: 'account.updatePasswordSettings', params: { password: InputCheckPasswordSRP, new_settings: account_PasswordInputSettings }): Promise<Bool>;
  call(method: 'auth.checkPassword', params: { password: InputCheckPasswordSRP }): Promise<auth_Authorization>;
  call(method: 'auth.requestPasswordRecovery'): Promise<auth_PasswordRecovery>;
  call(method: 'auth.recoverPassword', params: { flags: #, code: string, new_settings?: account_PasswordInputSettings }): Promise<auth_Authorization>;
  call(method: 'invokeWithoutUpdates', params: { query: !X }): Promise<X>;
  call(method: 'messages.exportChatInvite', params: { flags: #, legacy_revoke_permanent?: boolean, request_needed?: boolean, peer: InputPeer, expire_date?: number, usage_limit?: number, title?: string }): Promise<ExportedChatInvite>;
  call(method: 'messages.checkChatInvite', params: { hash: string }): Promise<ChatInvite>;
  call(method: 'messages.importChatInvite', params: { hash: string }): Promise<Updates>;
  call(method: 'messages.getStickerSet', params: { stickerset: InputStickerSet, hash: number }): Promise<messages_StickerSet>;
  call(method: 'messages.installStickerSet', params: { stickerset: InputStickerSet, archived: boolean }): Promise<messages_StickerSetInstallResult>;
  call(method: 'messages.uninstallStickerSet', params: { stickerset: InputStickerSet }): Promise<Bool>;
  call(method: 'messages.startBot', params: { bot: InputUser, peer: InputPeer, random_id: number, start_param: string }): Promise<Updates>;
  call(method: 'help.getAppChangelog', params: { prev_app_version: string }): Promise<Updates>;
  call(method: 'messages.getMessagesViews', params: { peer: InputPeer, id: number[], increment: boolean }): Promise<messages_MessageViews>;
  call(method: 'channels.readHistory', params: { channel: InputChannel, max_id: number }): Promise<Bool>;
  call(method: 'channels.deleteMessages', params: { channel: InputChannel, id: number[] }): Promise<messages_AffectedMessages>;
  call(method: 'channels.reportSpam', params: { channel: InputChannel, participant: InputPeer, id: number[] }): Promise<Bool>;
  call(method: 'channels.getMessages', params: { channel: InputChannel, id: InputMessage[] }): Promise<messages_Messages>;
  call(method: 'channels.getParticipants', params: { channel: InputChannel, filter: ChannelParticipantsFilter, offset: number, limit: number, hash: number }): Promise<channels_ChannelParticipants>;
  call(method: 'channels.getParticipant', params: { channel: InputChannel, participant: InputPeer }): Promise<channels_ChannelParticipant>;
  call(method: 'channels.getChannels', params: { id: InputChannel[] }): Promise<messages_Chats>;
  call(method: 'channels.getFullChannel', params: { channel: InputChannel }): Promise<messages_ChatFull>;
  call(method: 'channels.createChannel', params: { flags: #, broadcast?: boolean, megagroup?: boolean, for_import?: boolean, title: string, about: string, geo_point?: InputGeoPoint, address?: string }): Promise<Updates>;
  call(method: 'channels.editAdmin', params: { channel: InputChannel, user_id: InputUser, admin_rights: ChatAdminRights, rank: string }): Promise<Updates>;
  call(method: 'channels.editTitle', params: { channel: InputChannel, title: string }): Promise<Updates>;
  call(method: 'channels.editPhoto', params: { channel: InputChannel, photo: InputChatPhoto }): Promise<Updates>;
  call(method: 'channels.checkUsername', params: { channel: InputChannel, username: string }): Promise<Bool>;
  call(method: 'channels.updateUsername', params: { channel: InputChannel, username: string }): Promise<Bool>;
  call(method: 'channels.joinChannel', params: { channel: InputChannel }): Promise<Updates>;
  call(method: 'channels.leaveChannel', params: { channel: InputChannel }): Promise<Updates>;
  call(method: 'channels.inviteToChannel', params: { channel: InputChannel, users: InputUser[] }): Promise<Updates>;
  call(method: 'channels.deleteChannel', params: { channel: InputChannel }): Promise<Updates>;
  call(method: 'updates.getChannelDifference', params: { flags: #, force?: boolean, channel: InputChannel, filter: ChannelMessagesFilter, pts: number, limit: number }): Promise<updates_ChannelDifference>;
  call(method: 'messages.editChatAdmin', params: { chat_id: number, user_id: InputUser, is_admin: boolean }): Promise<Bool>;
  call(method: 'messages.migrateChat', params: { chat_id: number }): Promise<Updates>;
  call(method: 'messages.searchGlobal', params: { flags: #, folder_id?: number, q: string, filter: MessagesFilter, min_date: number, max_date: number, offset_rate: number, offset_peer: InputPeer, offset_id: number, limit: number }): Promise<messages_Messages>;
  call(method: 'messages.reorderStickerSets', params: { flags: #, masks?: boolean, emojis?: boolean, order: number[] }): Promise<Bool>;
  call(method: 'messages.getDocumentByHash', params: { sha256: UInt8Array, size: number, mime_type: string }): Promise<Document>;
  call(method: 'messages.getSavedGifs', params: { hash: number }): Promise<messages_SavedGifs>;
  call(method: 'messages.saveGif', params: { id: InputDocument, unsave: boolean }): Promise<Bool>;
  call(method: 'messages.getInlineBotResults', params: { flags: #, bot: InputUser, peer: InputPeer, geo_point?: InputGeoPoint, query: string, offset: string }): Promise<messages_BotResults>;
  call(method: 'messages.setInlineBotResults', params: { flags: #, gallery?: boolean, private?: boolean, query_id: number, results: InputBotInlineResult[], cache_time: number, next_offset?: string, switch_pm?: InlineBotSwitchPM }): Promise<Bool>;
  call(method: 'messages.sendInlineBotResult', params: { flags: #, silent?: boolean, background?: boolean, clear_draft?: boolean, hide_via?: boolean, peer: InputPeer, reply_to_msg_id?: number, random_id: number, query_id: number, id: string, schedule_date?: number, send_as?: InputPeer }): Promise<Updates>;
  call(method: 'channels.exportMessageLink', params: { flags: #, grouped?: boolean, thread?: boolean, channel: InputChannel, id: number }): Promise<ExportedMessageLink>;
  call(method: 'channels.toggleSignatures', params: { channel: InputChannel, enabled: boolean }): Promise<Updates>;
  call(method: 'auth.resendCode', params: { phone_number: string, phone_code_hash: string }): Promise<auth_SentCode>;
  call(method: 'auth.cancelCode', params: { phone_number: string, phone_code_hash: string }): Promise<Bool>;
  call(method: 'messages.getMessageEditData', params: { peer: InputPeer, id: number }): Promise<messages_MessageEditData>;
  call(method: 'messages.editMessage', params: { flags: #, no_webpage?: boolean, peer: InputPeer, id: number, message?: string, media?: InputMedia, reply_markup?: ReplyMarkup, entities?: MessageEntity[], schedule_date?: number }): Promise<Updates>;
  call(method: 'messages.editInlineBotMessage', params: { flags: #, no_webpage?: boolean, id: InputBotInlineMessageID, message?: string, media?: InputMedia, reply_markup?: ReplyMarkup, entities?: MessageEntity[] }): Promise<Bool>;
  call(method: 'messages.getBotCallbackAnswer', params: { flags: #, game?: boolean, peer: InputPeer, msg_id: number, data?: UInt8Array, password?: InputCheckPasswordSRP }): Promise<messages_BotCallbackAnswer>;
  call(method: 'messages.setBotCallbackAnswer', params: { flags: #, alert?: boolean, query_id: number, message?: string, url?: string, cache_time: number }): Promise<Bool>;
  call(method: 'contacts.getTopPeers', params: { flags: #, correspondents?: boolean, bots_pm?: boolean, bots_inline?: boolean, phone_calls?: boolean, forward_users?: boolean, forward_chats?: boolean, groups?: boolean, channels?: boolean, offset: number, limit: number, hash: number }): Promise<contacts_TopPeers>;
  call(method: 'contacts.resetTopPeerRating', params: { category: TopPeerCategory, peer: InputPeer }): Promise<Bool>;
  call(method: 'messages.getPeerDialogs', params: { peers: InputDialogPeer[] }): Promise<messages_PeerDialogs>;
  call(method: 'messages.saveDraft', params: { flags: #, no_webpage?: boolean, reply_to_msg_id?: number, peer: InputPeer, message: string, entities?: MessageEntity[] }): Promise<Bool>;
  call(method: 'messages.getAllDrafts'): Promise<Updates>;
  call(method: 'messages.getFeaturedStickers', params: { hash: number }): Promise<messages_FeaturedStickers>;
  call(method: 'messages.readFeaturedStickers', params: { id: number[] }): Promise<Bool>;
  call(method: 'messages.getRecentStickers', params: { flags: #, attached?: boolean, hash: number }): Promise<messages_RecentStickers>;
  call(method: 'messages.saveRecentSticker', params: { flags: #, attached?: boolean, id: InputDocument, unsave: boolean }): Promise<Bool>;
  call(method: 'messages.clearRecentStickers', params: { flags: #, attached?: boolean }): Promise<Bool>;
  call(method: 'messages.getArchivedStickers', params: { flags: #, masks?: boolean, emojis?: boolean, offset_id: number, limit: number }): Promise<messages_ArchivedStickers>;
  call(method: 'account.sendConfirmPhoneCode', params: { hash: string, settings: CodeSettings }): Promise<auth_SentCode>;
  call(method: 'account.confirmPhone', params: { phone_code_hash: string, phone_code: string }): Promise<Bool>;
  call(method: 'channels.getAdminedPublicChannels', params: { flags: #, by_location?: boolean, check_limit?: boolean }): Promise<messages_Chats>;
  call(method: 'messages.getMaskStickers', params: { hash: number }): Promise<messages_AllStickers>;
  call(method: 'messages.getAttachedStickers', params: { media: InputStickeredMedia }): Promise<Vector<StickerSetCovered>>;
  call(method: 'auth.dropTempAuthKeys', params: { except_auth_keys: number[] }): Promise<Bool>;
  call(method: 'messages.setGameScore', params: { flags: #, edit_message?: boolean, force?: boolean, peer: InputPeer, id: number, user_id: InputUser, score: number }): Promise<Updates>;
  call(method: 'messages.setInlineGameScore', params: { flags: #, edit_message?: boolean, force?: boolean, id: InputBotInlineMessageID, user_id: InputUser, score: number }): Promise<Bool>;
  call(method: 'messages.getGameHighScores', params: { peer: InputPeer, id: number, user_id: InputUser }): Promise<messages_HighScores>;
  call(method: 'messages.getInlineGameHighScores', params: { id: InputBotInlineMessageID, user_id: InputUser }): Promise<messages_HighScores>;
  call(method: 'messages.getCommonChats', params: { user_id: InputUser, max_id: number, limit: number }): Promise<messages_Chats>;
  call(method: 'messages.getAllChats', params: { except_ids: number[] }): Promise<messages_Chats>;
  call(method: 'help.setBotUpdatesStatus', params: { pending_updates_count: number, message: string }): Promise<Bool>;
  call(method: 'messages.getWebPage', params: { url: string, hash: number }): Promise<WebPage>;
  call(method: 'messages.toggleDialogPin', params: { flags: #, pinned?: boolean, peer: InputDialogPeer }): Promise<Bool>;
  call(method: 'messages.reorderPinnedDialogs', params: { flags: #, force?: boolean, folder_id: number, order: InputDialogPeer[] }): Promise<Bool>;
  call(method: 'messages.getPinnedDialogs', params: { folder_id: number }): Promise<messages_PeerDialogs>;
  call(method: 'bots.sendCustomRequest', params: { custom_method: string, params: DataJSON }): Promise<DataJSON>;
  call(method: 'bots.answerWebhookJSONQuery', params: { query_id: number, data: DataJSON }): Promise<Bool>;
  call(method: 'upload.getWebFile', params: { location: InputWebFileLocation, offset: number, limit: number }): Promise<upload_WebFile>;
  call(method: 'payments.getPaymentForm', params: { flags: #, peer: InputPeer, msg_id: number, theme_params?: DataJSON }): Promise<payments_PaymentForm>;
  call(method: 'payments.getPaymentReceipt', params: { peer: InputPeer, msg_id: number }): Promise<payments_PaymentReceipt>;
  call(method: 'payments.validateRequestedInfo', params: { flags: #, save?: boolean, peer: InputPeer, msg_id: number, info: PaymentRequestedInfo }): Promise<payments_ValidatedRequestedInfo>;
  call(method: 'payments.sendPaymentForm', params: { flags: #, form_id: number, peer: InputPeer, msg_id: number, requested_info_id?: string, shipping_option_id?: string, credentials: InputPaymentCredentials, tip_amount?: number }): Promise<payments_PaymentResult>;
  call(method: 'account.getTmpPassword', params: { password: InputCheckPasswordSRP, period: number }): Promise<account_TmpPassword>;
  call(method: 'payments.getSavedInfo'): Promise<payments_SavedInfo>;
  call(method: 'payments.clearSavedInfo', params: { flags: #, credentials?: boolean, info?: boolean }): Promise<Bool>;
  call(method: 'messages.setBotShippingResults', params: { flags: #, query_id: number, error?: string, shipping_options?: ShippingOption[] }): Promise<Bool>;
  call(method: 'messages.setBotPrecheckoutResults', params: { flags: #, success?: boolean, query_id: number, error?: string }): Promise<Bool>;
  call(method: 'stickers.createStickerSet', params: { flags: #, masks?: boolean, animated?: boolean, videos?: boolean, user_id: InputUser, title: string, short_name: string, thumb?: InputDocument, stickers: InputStickerSetItem[], software?: string }): Promise<messages_StickerSet>;
  call(method: 'stickers.removeStickerFromSet', params: { sticker: InputDocument }): Promise<messages_StickerSet>;
  call(method: 'stickers.changeStickerPosition', params: { sticker: InputDocument, position: number }): Promise<messages_StickerSet>;
  call(method: 'stickers.addStickerToSet', params: { stickerset: InputStickerSet, sticker: InputStickerSetItem }): Promise<messages_StickerSet>;
  call(method: 'messages.uploadMedia', params: { peer: InputPeer, media: InputMedia }): Promise<MessageMedia>;
  call(method: 'phone.getCallConfig'): Promise<DataJSON>;
  call(method: 'phone.requestCall', params: { flags: #, video?: boolean, user_id: InputUser, random_id: number, g_a_hash: UInt8Array, protocol: PhoneCallProtocol }): Promise<phone_PhoneCall>;
  call(method: 'phone.acceptCall', params: { peer: InputPhoneCall, g_b: UInt8Array, protocol: PhoneCallProtocol }): Promise<phone_PhoneCall>;
  call(method: 'phone.confirmCall', params: { peer: InputPhoneCall, g_a: UInt8Array, key_fingerprint: number, protocol: PhoneCallProtocol }): Promise<phone_PhoneCall>;
  call(method: 'phone.receivedCall', params: { peer: InputPhoneCall }): Promise<Bool>;
  call(method: 'phone.discardCall', params: { flags: #, video?: boolean, peer: InputPhoneCall, duration: number, reason: PhoneCallDiscardReason, connection_id: number }): Promise<Updates>;
  call(method: 'phone.setCallRating', params: { flags: #, user_initiative?: boolean, peer: InputPhoneCall, rating: number, comment: string }): Promise<Updates>;
  call(method: 'phone.saveCallDebug', params: { peer: InputPhoneCall, debug: DataJSON }): Promise<Bool>;
  call(method: 'upload.getCdnFile', params: { file_token: UInt8Array, offset: number, limit: number }): Promise<upload_CdnFile>;
  call(method: 'upload.reuploadCdnFile', params: { file_token: UInt8Array, request_token: UInt8Array }): Promise<Vector<FileHash>>;
  call(method: 'help.getCdnConfig'): Promise<CdnConfig>;
  call(method: 'langpack.getLangPack', params: { lang_pack: string, lang_code: string }): Promise<LangPackDifference>;
  call(method: 'langpack.getStrings', params: { lang_pack: string, lang_code: string, keys: string[] }): Promise<Vector<LangPackString>>;
  call(method: 'langpack.getDifference', params: { lang_pack: string, lang_code: string, from_version: number }): Promise<LangPackDifference>;
  call(method: 'langpack.getLanguages', params: { lang_pack: string }): Promise<Vector<LangPackLanguage>>;
  call(method: 'channels.editBanned', params: { channel: InputChannel, participant: InputPeer, banned_rights: ChatBannedRights }): Promise<Updates>;
  call(method: 'channels.getAdminLog', params: { flags: #, channel: InputChannel, q: string, events_filter?: ChannelAdminLogEventsFilter, admins?: InputUser[], max_id: number, min_id: number, limit: number }): Promise<channels_AdminLogResults>;
  call(method: 'upload.getCdnFileHashes', params: { file_token: UInt8Array, offset: number }): Promise<Vector<FileHash>>;
  call(method: 'messages.sendScreenshotNotification', params: { peer: InputPeer, reply_to_msg_id: number, random_id: number }): Promise<Updates>;
  call(method: 'channels.setStickers', params: { channel: InputChannel, stickerset: InputStickerSet }): Promise<Bool>;
  call(method: 'messages.getFavedStickers', params: { hash: number }): Promise<messages_FavedStickers>;
  call(method: 'messages.faveSticker', params: { id: InputDocument, unfave: boolean }): Promise<Bool>;
  call(method: 'channels.readMessageContents', params: { channel: InputChannel, id: number[] }): Promise<Bool>;
  call(method: 'contacts.resetSaved'): Promise<Bool>;
  call(method: 'messages.getUnreadMentions', params: { peer: InputPeer, offset_id: number, add_offset: number, limit: number, max_id: number, min_id: number }): Promise<messages_Messages>;
  call(method: 'channels.deleteHistory', params: { channel: InputChannel, max_id: number }): Promise<Bool>;
  call(method: 'help.getRecentMeUrls', params: { referer: string }): Promise<help_RecentMeUrls>;
  call(method: 'channels.togglePreHistoryHidden', params: { channel: InputChannel, enabled: boolean }): Promise<Updates>;
  call(method: 'messages.readMentions', params: { peer: InputPeer }): Promise<messages_AffectedHistory>;
  call(method: 'messages.getRecentLocations', params: { peer: InputPeer, limit: number, hash: number }): Promise<messages_Messages>;
  call(method: 'messages.sendMultiMedia', params: { flags: #, silent?: boolean, background?: boolean, clear_draft?: boolean, noforwards?: boolean, peer: InputPeer, reply_to_msg_id?: number, multi_media: InputSingleMedia[], schedule_date?: number, send_as?: InputPeer }): Promise<Updates>;
  call(method: 'messages.uploadEncryptedFile', params: { peer: InputEncryptedChat, file: InputEncryptedFile }): Promise<EncryptedFile>;
  call(method: 'account.getWebAuthorizations'): Promise<account_WebAuthorizations>;
  call(method: 'account.resetWebAuthorization', params: { hash: number }): Promise<Bool>;
  call(method: 'account.resetWebAuthorizations'): Promise<Bool>;
  call(method: 'messages.searchStickerSets', params: { flags: #, exclude_featured?: boolean, q: string, hash: number }): Promise<messages_FoundStickerSets>;
  call(method: 'upload.getFileHashes', params: { location: InputFileLocation, offset: number }): Promise<Vector<FileHash>>;
  call(method: 'help.getTermsOfServiceUpdate'): Promise<help_TermsOfServiceUpdate>;
  call(method: 'help.acceptTermsOfService', params: { id: DataJSON }): Promise<Bool>;
  call(method: 'account.getAllSecureValues'): Promise<Vector<SecureValue>>;
  call(method: 'account.getSecureValue', params: { types: SecureValueType[] }): Promise<Vector<SecureValue>>;
  call(method: 'account.saveSecureValue', params: { value: InputSecureValue, secure_secret_id: number }): Promise<SecureValue>;
  call(method: 'account.deleteSecureValue', params: { types: SecureValueType[] }): Promise<Bool>;
  call(method: 'users.setSecureValueErrors', params: { id: InputUser, errors: SecureValueError[] }): Promise<Bool>;
  call(method: 'account.getAuthorizationForm', params: { bot_id: number, scope: string, public_key: string }): Promise<account_AuthorizationForm>;
  call(method: 'account.acceptAuthorization', params: { bot_id: number, scope: string, public_key: string, value_hashes: SecureValueHash[], credentials: SecureCredentialsEncrypted }): Promise<Bool>;
  call(method: 'account.sendVerifyPhoneCode', params: { phone_number: string, settings: CodeSettings }): Promise<auth_SentCode>;
  call(method: 'account.verifyPhone', params: { phone_number: string, phone_code_hash: string, phone_code: string }): Promise<Bool>;
  call(method: 'account.sendVerifyEmailCode', params: { email: string }): Promise<account_SentEmailCode>;
  call(method: 'account.verifyEmail', params: { email: string, code: string }): Promise<Bool>;
  call(method: 'help.getDeepLinkInfo', params: { path: string }): Promise<help_DeepLinkInfo>;
  call(method: 'contacts.getSaved'): Promise<Vector<SavedContact>>;
  call(method: 'channels.getLeftChannels', params: { offset: number }): Promise<messages_Chats>;
  call(method: 'account.initTakeoutSession', params: { flags: #, contacts?: boolean, message_users?: boolean, message_chats?: boolean, message_megagroups?: boolean, message_channels?: boolean, files?: boolean, file_max_size?: number }): Promise<account_Takeout>;
  call(method: 'account.finishTakeoutSession', params: { flags: #, success?: boolean }): Promise<Bool>;
  call(method: 'messages.getSplitRanges'): Promise<Vector<MessageRange>>;
  call(method: 'invokeWithMessagesRange', params: { range: MessageRange, query: !X }): Promise<X>;
  call(method: 'invokeWithTakeout', params: { takeout_id: number, query: !X }): Promise<X>;
  call(method: 'messages.markDialogUnread', params: { flags: #, unread?: boolean, peer: InputDialogPeer }): Promise<Bool>;
  call(method: 'messages.getDialogUnreadMarks'): Promise<Vector<DialogPeer>>;
  call(method: 'contacts.toggleTopPeers', params: { enabled: boolean }): Promise<Bool>;
  call(method: 'messages.clearAllDrafts'): Promise<Bool>;
  call(method: 'help.getAppConfig'): Promise<JSONValue>;
  call(method: 'help.saveAppLog', params: { events: InputAppEvent[] }): Promise<Bool>;
  call(method: 'help.getPassportConfig', params: { hash: number }): Promise<help_PassportConfig>;
  call(method: 'langpack.getLanguage', params: { lang_pack: string, lang_code: string }): Promise<LangPackLanguage>;
  call(method: 'messages.updatePinnedMessage', params: { flags: #, silent?: boolean, unpin?: boolean, pm_oneside?: boolean, peer: InputPeer, id: number }): Promise<Updates>;
  call(method: 'account.confirmPasswordEmail', params: { code: string }): Promise<Bool>;
  call(method: 'account.resendPasswordEmail'): Promise<Bool>;
  call(method: 'account.cancelPasswordEmail'): Promise<Bool>;
  call(method: 'help.getSupportName'): Promise<help_SupportName>;
  call(method: 'help.getUserInfo', params: { user_id: InputUser }): Promise<help_UserInfo>;
  call(method: 'help.editUserInfo', params: { user_id: InputUser, message: string, entities: MessageEntity[] }): Promise<help_UserInfo>;
  call(method: 'account.getContactSignUpNotification'): Promise<Bool>;
  call(method: 'account.setContactSignUpNotification', params: { silent: boolean }): Promise<Bool>;
  call(method: 'account.getNotifyExceptions', params: { flags: #, compare_sound?: boolean, peer?: InputNotifyPeer }): Promise<Updates>;
  call(method: 'messages.sendVote', params: { peer: InputPeer, msg_id: number, options: UInt8Array[] }): Promise<Updates>;
  call(method: 'messages.getPollResults', params: { peer: InputPeer, msg_id: number }): Promise<Updates>;
  call(method: 'messages.getOnlines', params: { peer: InputPeer }): Promise<ChatOnlines>;
  call(method: 'messages.editChatAbout', params: { peer: InputPeer, about: string }): Promise<Bool>;
  call(method: 'messages.editChatDefaultBannedRights', params: { peer: InputPeer, banned_rights: ChatBannedRights }): Promise<Updates>;
  call(method: 'account.getWallPaper', params: { wallpaper: InputWallPaper }): Promise<WallPaper>;
  call(method: 'account.uploadWallPaper', params: { file: InputFile, mime_type: string, settings: WallPaperSettings }): Promise<WallPaper>;
  call(method: 'account.saveWallPaper', params: { wallpaper: InputWallPaper, unsave: boolean, settings: WallPaperSettings }): Promise<Bool>;
  call(method: 'account.installWallPaper', params: { wallpaper: InputWallPaper, settings: WallPaperSettings }): Promise<Bool>;
  call(method: 'account.resetWallPapers'): Promise<Bool>;
  call(method: 'account.getAutoDownloadSettings'): Promise<account_AutoDownloadSettings>;
  call(method: 'account.saveAutoDownloadSettings', params: { flags: #, low?: boolean, high?: boolean, settings: AutoDownloadSettings }): Promise<Bool>;
  call(method: 'messages.getEmojiKeywords', params: { lang_code: string }): Promise<EmojiKeywordsDifference>;
  call(method: 'messages.getEmojiKeywordsDifference', params: { lang_code: string, from_version: number }): Promise<EmojiKeywordsDifference>;
  call(method: 'messages.getEmojiKeywordsLanguages', params: { lang_codes: string[] }): Promise<Vector<EmojiLanguage>>;
  call(method: 'messages.getEmojiURL', params: { lang_code: string }): Promise<EmojiURL>;
  call(method: 'folders.editPeerFolders', params: { folder_peers: InputFolderPeer[] }): Promise<Updates>;
  call(method: 'folders.deleteFolder', params: { folder_id: number }): Promise<Updates>;
  call(method: 'messages.getSearchCounters', params: { peer: InputPeer, filters: MessagesFilter[] }): Promise<Vector<messages_SearchCounter>>;
  call(method: 'channels.getGroupsForDiscussion'): Promise<messages_Chats>;
  call(method: 'channels.setDiscussionGroup', params: { broadcast: InputChannel, group: InputChannel }): Promise<Bool>;
  call(method: 'messages.requestUrlAuth', params: { flags: #, peer?: InputPeer, msg_id?: number, button_id?: number, url?: string }): Promise<UrlAuthResult>;
  call(method: 'messages.acceptUrlAuth', params: { flags: #, write_allowed?: boolean, peer?: InputPeer, msg_id?: number, button_id?: number, url?: string }): Promise<UrlAuthResult>;
  call(method: 'messages.hidePeerSettingsBar', params: { peer: InputPeer }): Promise<Bool>;
  call(method: 'contacts.addContact', params: { flags: #, add_phone_privacy_exception?: boolean, id: InputUser, first_name: string, last_name: string, phone: string }): Promise<Updates>;
  call(method: 'contacts.acceptContact', params: { id: InputUser }): Promise<Updates>;
  call(method: 'channels.editCreator', params: { channel: InputChannel, user_id: InputUser, password: InputCheckPasswordSRP }): Promise<Updates>;
  call(method: 'contacts.getLocated', params: { flags: #, background?: boolean, geo_point: InputGeoPoint, self_expires?: number }): Promise<Updates>;
  call(method: 'channels.editLocation', params: { channel: InputChannel, geo_point: InputGeoPoint, address: string }): Promise<Bool>;
  call(method: 'channels.toggleSlowMode', params: { channel: InputChannel, seconds: number }): Promise<Updates>;
  call(method: 'messages.getScheduledHistory', params: { peer: InputPeer, hash: number }): Promise<messages_Messages>;
  call(method: 'messages.getScheduledMessages', params: { peer: InputPeer, id: number[] }): Promise<messages_Messages>;
  call(method: 'messages.sendScheduledMessages', params: { peer: InputPeer, id: number[] }): Promise<Updates>;
  call(method: 'messages.deleteScheduledMessages', params: { peer: InputPeer, id: number[] }): Promise<Updates>;
  call(method: 'account.uploadTheme', params: { flags: #, file: InputFile, thumb?: InputFile, file_name: string, mime_type: string }): Promise<Document>;
  call(method: 'account.createTheme', params: { flags: #, slug: string, title: string, document?: InputDocument, settings?: InputThemeSettings[] }): Promise<Theme>;
  call(method: 'account.updateTheme', params: { flags: #, format: string, theme: InputTheme, slug?: string, title?: string, document?: InputDocument, settings?: InputThemeSettings[] }): Promise<Theme>;
  call(method: 'account.saveTheme', params: { theme: InputTheme, unsave: boolean }): Promise<Bool>;
  call(method: 'account.installTheme', params: { flags: #, dark?: boolean, theme?: InputTheme, format?: string, base_theme?: BaseTheme }): Promise<Bool>;
  call(method: 'account.getTheme', params: { format: string, theme: InputTheme, document_id: number }): Promise<Theme>;
  call(method: 'account.getThemes', params: { format: string, hash: number }): Promise<account_Themes>;
  call(method: 'auth.exportLoginToken', params: { api_id: number, api_hash: string, except_ids: number[] }): Promise<auth_LoginToken>;
  call(method: 'auth.importLoginToken', params: { token: UInt8Array }): Promise<auth_LoginToken>;
  call(method: 'auth.acceptLoginToken', params: { token: UInt8Array }): Promise<Authorization>;
  call(method: 'account.setContentSettings', params: { flags: #, sensitive_enabled?: boolean }): Promise<Bool>;
  call(method: 'account.getContentSettings'): Promise<account_ContentSettings>;
  call(method: 'channels.getInactiveChannels'): Promise<messages_InactiveChats>;
  call(method: 'account.getMultiWallPapers', params: { wallpapers: InputWallPaper[] }): Promise<Vector<WallPaper>>;
  call(method: 'messages.getPollVotes', params: { flags: #, peer: InputPeer, id: number, option?: UInt8Array, offset?: string, limit: number }): Promise<messages_VotesList>;
  call(method: 'messages.toggleStickerSets', params: { flags: #, uninstall?: boolean, archive?: boolean, unarchive?: boolean, stickersets: InputStickerSet[] }): Promise<Bool>;
  call(method: 'payments.getBankCardData', params: { number: string }): Promise<payments_BankCardData>;
  call(method: 'messages.getDialogFilters'): Promise<Vector<DialogFilter>>;
  call(method: 'messages.getSuggestedDialogFilters'): Promise<Vector<DialogFilterSuggested>>;
  call(method: 'messages.updateDialogFilter', params: { flags: #, id: number, filter?: DialogFilter }): Promise<Bool>;
  call(method: 'messages.updateDialogFiltersOrder', params: { order: number[] }): Promise<Bool>;
  call(method: 'stats.getBroadcastStats', params: { flags: #, dark?: boolean, channel: InputChannel }): Promise<stats_BroadcastStats>;
  call(method: 'stats.loadAsyncGraph', params: { flags: #, token: string, x?: number }): Promise<StatsGraph>;
  call(method: 'stickers.setStickerSetThumb', params: { stickerset: InputStickerSet, thumb: InputDocument }): Promise<messages_StickerSet>;
  call(method: 'bots.setBotCommands', params: { scope: BotCommandScope, lang_code: string, commands: BotCommand[] }): Promise<Bool>;
  call(method: 'messages.getOldFeaturedStickers', params: { offset: number, limit: number, hash: number }): Promise<messages_FeaturedStickers>;
  call(method: 'help.getPromoData'): Promise<help_PromoData>;
  call(method: 'help.hidePromoData', params: { peer: InputPeer }): Promise<Bool>;
  call(method: 'phone.sendSignalingData', params: { peer: InputPhoneCall, data: UInt8Array }): Promise<Bool>;
  call(method: 'stats.getMegagroupStats', params: { flags: #, dark?: boolean, channel: InputChannel }): Promise<stats_MegagroupStats>;
  call(method: 'account.getGlobalPrivacySettings'): Promise<GlobalPrivacySettings>;
  call(method: 'account.setGlobalPrivacySettings', params: { settings: GlobalPrivacySettings }): Promise<GlobalPrivacySettings>;
  call(method: 'help.dismissSuggestion', params: { peer: InputPeer, suggestion: string }): Promise<Bool>;
  call(method: 'help.getCountriesList', params: { lang_code: string, hash: number }): Promise<help_CountriesList>;
  call(method: 'messages.getReplies', params: { peer: InputPeer, msg_id: number, offset_id: number, offset_date: number, add_offset: number, limit: number, max_id: number, min_id: number, hash: number }): Promise<messages_Messages>;
  call(method: 'messages.getDiscussionMessage', params: { peer: InputPeer, msg_id: number }): Promise<messages_DiscussionMessage>;
  call(method: 'messages.readDiscussion', params: { peer: InputPeer, msg_id: number, read_max_id: number }): Promise<Bool>;
  call(method: 'contacts.blockFromReplies', params: { flags: #, delete_message?: boolean, delete_history?: boolean, report_spam?: boolean, msg_id: number }): Promise<Updates>;
  call(method: 'stats.getMessagePublicForwards', params: { channel: InputChannel, msg_id: number, offset_rate: number, offset_peer: InputPeer, offset_id: number, limit: number }): Promise<messages_Messages>;
  call(method: 'stats.getMessageStats', params: { flags: #, dark?: boolean, channel: InputChannel, msg_id: number }): Promise<stats_MessageStats>;
  call(method: 'messages.unpinAllMessages', params: { peer: InputPeer }): Promise<messages_AffectedHistory>;
  call(method: 'phone.createGroupCall', params: { flags: #, rtmp_stream?: boolean, peer: InputPeer, random_id: number, title?: string, schedule_date?: number }): Promise<Updates>;
  call(method: 'phone.joinGroupCall', params: { flags: #, muted?: boolean, video_stopped?: boolean, call: InputGroupCall, join_as: InputPeer, invite_hash?: string, params: DataJSON }): Promise<Updates>;
  call(method: 'phone.leaveGroupCall', params: { call: InputGroupCall, source: number }): Promise<Updates>;
  call(method: 'phone.inviteToGroupCall', params: { call: InputGroupCall, users: InputUser[] }): Promise<Updates>;
  call(method: 'phone.discardGroupCall', params: { call: InputGroupCall }): Promise<Updates>;
  call(method: 'phone.toggleGroupCallSettings', params: { flags: #, reset_invite_hash?: boolean, call: InputGroupCall, join_muted?: boolean }): Promise<Updates>;
  call(method: 'phone.getGroupCall', params: { call: InputGroupCall, limit: number }): Promise<phone_GroupCall>;
  call(method: 'phone.getGroupParticipants', params: { call: InputGroupCall, ids: InputPeer[], sources: number[], offset: string, limit: number }): Promise<phone_GroupParticipants>;
  call(method: 'phone.checkGroupCall', params: { call: InputGroupCall, sources: number[] }): Promise<Vector<int>>;
  call(method: 'messages.deleteChat', params: { chat_id: number }): Promise<Bool>;
  call(method: 'messages.deletePhoneCallHistory', params: { flags: #, revoke?: boolean }): Promise<messages_AffectedFoundMessages>;
  call(method: 'messages.checkHistoryImport', params: { import_head: string }): Promise<messages_HistoryImportParsed>;
  call(method: 'messages.initHistoryImport', params: { peer: InputPeer, file: InputFile, media_count: number }): Promise<messages_HistoryImport>;
  call(method: 'messages.uploadImportedMedia', params: { peer: InputPeer, import_id: number, file_name: string, media: InputMedia }): Promise<MessageMedia>;
  call(method: 'messages.startHistoryImport', params: { peer: InputPeer, import_id: number }): Promise<Bool>;
  call(method: 'messages.getExportedChatInvites', params: { flags: #, revoked?: boolean, peer: InputPeer, admin_id: InputUser, offset_date?: number, offset_link?: string, limit: number }): Promise<messages_ExportedChatInvites>;
  call(method: 'messages.getExportedChatInvite', params: { peer: InputPeer, link: string }): Promise<messages_ExportedChatInvite>;
  call(method: 'messages.editExportedChatInvite', params: { flags: #, revoked?: boolean, peer: InputPeer, link: string, expire_date?: number, usage_limit?: number, request_needed?: boolean, title?: string }): Promise<messages_ExportedChatInvite>;
  call(method: 'messages.deleteRevokedExportedChatInvites', params: { peer: InputPeer, admin_id: InputUser }): Promise<Bool>;
  call(method: 'messages.deleteExportedChatInvite', params: { peer: InputPeer, link: string }): Promise<Bool>;
  call(method: 'messages.getAdminsWithInvites', params: { peer: InputPeer }): Promise<messages_ChatAdminsWithInvites>;
  call(method: 'messages.getChatInviteImporters', params: { flags: #, requested?: boolean, peer: InputPeer, link?: string, q?: string, offset_date: number, offset_user: InputUser, limit: number }): Promise<messages_ChatInviteImporters>;
  call(method: 'messages.setHistoryTTL', params: { peer: InputPeer, period: number }): Promise<Updates>;
  call(method: 'account.reportProfilePhoto', params: { peer: InputPeer, photo_id: InputPhoto, reason: ReportReason, message: string }): Promise<Bool>;
  call(method: 'channels.convertToGigagroup', params: { channel: InputChannel }): Promise<Updates>;
  call(method: 'messages.checkHistoryImportPeer', params: { peer: InputPeer }): Promise<messages_CheckedHistoryImportPeer>;
  call(method: 'phone.toggleGroupCallRecord', params: { flags: #, start?: boolean, video?: boolean, call: InputGroupCall, title?: string, video_portrait?: boolean }): Promise<Updates>;
  call(method: 'phone.editGroupCallParticipant', params: { flags: #, call: InputGroupCall, participant: InputPeer, muted?: boolean, volume?: number, raise_hand?: boolean, video_stopped?: boolean, video_paused?: boolean, presentation_paused?: boolean }): Promise<Updates>;
  call(method: 'phone.editGroupCallTitle', params: { call: InputGroupCall, title: string }): Promise<Updates>;
  call(method: 'phone.getGroupCallJoinAs', params: { peer: InputPeer }): Promise<phone_JoinAsPeers>;
  call(method: 'phone.exportGroupCallInvite', params: { flags: #, can_self_unmute?: boolean, call: InputGroupCall }): Promise<phone_ExportedGroupCallInvite>;
  call(method: 'phone.toggleGroupCallStartSubscription', params: { call: InputGroupCall, subscribed: boolean }): Promise<Updates>;
  call(method: 'phone.startScheduledGroupCall', params: { call: InputGroupCall }): Promise<Updates>;
  call(method: 'phone.saveDefaultGroupCallJoinAs', params: { peer: InputPeer, join_as: InputPeer }): Promise<Bool>;
  call(method: 'phone.joinGroupCallPresentation', params: { call: InputGroupCall, params: DataJSON }): Promise<Updates>;
  call(method: 'phone.leaveGroupCallPresentation', params: { call: InputGroupCall }): Promise<Updates>;
  call(method: 'stickers.checkShortName', params: { short_name: string }): Promise<Bool>;
  call(method: 'stickers.suggestShortName', params: { title: string }): Promise<stickers_SuggestedShortName>;
  call(method: 'bots.resetBotCommands', params: { scope: BotCommandScope, lang_code: string }): Promise<Bool>;
  call(method: 'bots.getBotCommands', params: { scope: BotCommandScope, lang_code: string }): Promise<Vector<BotCommand>>;
  call(method: 'account.resetPassword'): Promise<account_ResetPasswordResult>;
  call(method: 'account.declinePasswordReset'): Promise<Bool>;
  call(method: 'auth.checkRecoveryPassword', params: { code: string }): Promise<Bool>;
  call(method: 'account.getChatThemes', params: { hash: number }): Promise<account_Themes>;
  call(method: 'messages.setChatTheme', params: { peer: InputPeer, emoticon: string }): Promise<Updates>;
  call(method: 'channels.viewSponsoredMessage', params: { channel: InputChannel, random_id: UInt8Array }): Promise<Bool>;
  call(method: 'channels.getSponsoredMessages', params: { channel: InputChannel }): Promise<messages_SponsoredMessages>;
  call(method: 'messages.getMessageReadParticipants', params: { peer: InputPeer, msg_id: number }): Promise<Vector<long>>;
  call(method: 'messages.getSearchResultsCalendar', params: { peer: InputPeer, filter: MessagesFilter, offset_id: number, offset_date: number }): Promise<messages_SearchResultsCalendar>;
  call(method: 'messages.getSearchResultsPositions', params: { peer: InputPeer, filter: MessagesFilter, offset_id: number, limit: number }): Promise<messages_SearchResultsPositions>;
  call(method: 'messages.hideChatJoinRequest', params: { flags: #, approved?: boolean, peer: InputPeer, user_id: InputUser }): Promise<Updates>;
  call(method: 'messages.hideAllChatJoinRequests', params: { flags: #, approved?: boolean, peer: InputPeer, link?: string }): Promise<Updates>;
  call(method: 'messages.toggleNoForwards', params: { peer: InputPeer, enabled: boolean }): Promise<Updates>;
  call(method: 'messages.saveDefaultSendAs', params: { peer: InputPeer, send_as: InputPeer }): Promise<Bool>;
  call(method: 'channels.getSendAs', params: { peer: InputPeer }): Promise<channels_SendAsPeers>;
  call(method: 'account.setAuthorizationTTL', params: { authorization_ttl_days: number }): Promise<Bool>;
  call(method: 'account.changeAuthorizationSettings', params: { flags: #, hash: number, encrypted_requests_disabled?: boolean, call_requests_disabled?: boolean }): Promise<Bool>;
  call(method: 'channels.deleteParticipantHistory', params: { channel: InputChannel, participant: InputPeer }): Promise<messages_AffectedHistory>;
  call(method: 'messages.sendReaction', params: { flags: #, big?: boolean, peer: InputPeer, msg_id: number, reaction?: string }): Promise<Updates>;
  call(method: 'messages.getMessagesReactions', params: { peer: InputPeer, id: number[] }): Promise<Updates>;
  call(method: 'messages.getMessageReactionsList', params: { flags: #, peer: InputPeer, id: number, reaction?: string, offset?: string, limit: number }): Promise<messages_MessageReactionsList>;
  call(method: 'messages.setChatAvailableReactions', params: { peer: InputPeer, available_reactions: string[] }): Promise<Updates>;
  call(method: 'messages.getAvailableReactions', params: { hash: number }): Promise<messages_AvailableReactions>;
  call(method: 'messages.setDefaultReaction', params: { reaction: string }): Promise<Bool>;
  call(method: 'messages.translateText', params: { flags: #, peer?: InputPeer, msg_id?: number, text?: string, from_lang?: string, to_lang: string }): Promise<messages_TranslatedText>;
  call(method: 'messages.getUnreadReactions', params: { peer: InputPeer, offset_id: number, add_offset: number, limit: number, max_id: number, min_id: number }): Promise<messages_Messages>;
  call(method: 'messages.readReactions', params: { peer: InputPeer }): Promise<messages_AffectedHistory>;
  call(method: 'contacts.resolvePhone', params: { phone: string }): Promise<contacts_ResolvedPeer>;
  call(method: 'phone.getGroupCallStreamChannels', params: { call: InputGroupCall }): Promise<phone_GroupCallStreamChannels>;
  call(method: 'phone.getGroupCallStreamRtmpUrl', params: { peer: InputPeer, revoke: boolean }): Promise<phone_GroupCallStreamRtmpUrl>;
  call(method: 'messages.searchSentMedia', params: { q: string, filter: MessagesFilter, limit: number }): Promise<messages_Messages>;

  setDefaultDc(dcId: number): Promise<string>;

  updates: {
    on(updateName: EventType, handler: EventHandler): void;
    off(updateName: EventType): void;
    removeAllListeners(): void;
  };

  crypto: {
    getSRPParams: typeof getSRPParams;
  };
}

export class MyAsyncLocalStorage {
  setItem(key: string, value: string): Promise<void>;
  getItem(key: string): Promise<string|null>;
}

export type EventType = 'updatesTooLong'
  | 'updateShortMessage'
  | 'updateShortChatMessage'
  | 'updateShort'
  | 'updatesCombined'
  | 'updates'
  | 'updateShortSentMessage';
export type EventHandler = (eventData: { [key: string]: any }) => any;

export function getSRPParams(params: {
  g: number,
  p: Uint8Array,
  salt1: Uint8Array,
  salt2: Uint8Array,
  gB: Uint8Array,
  password: string,
}): Promise<{
  A: Uint8Array,
  M1: Uint8Array;
}>;

